// DMA to PIO Test - Find the DMA issue
#include <hardware/pio.h>
#include <hardware/dma.h>
#include <hardware/gpio.h>
#include "simple_tx.pio.h"

constexpr size_t TX_DATA_PIN = 0;
constexpr size_t RX_DATA_PIN = 3;

PIO tx_pio = pio0;
uint tx_sm;
int dma_chan;

// Test buffer - simple patterns
uint8_t test_buffer[8] = {0x00, 0xFF, 0xAA, 0x55, 0xF0, 0x0F, 0x01, 0x80};
volatile bool dma_complete = false;

void __isr dma_handler() {
  dma_hw->ints0 = 1u << dma_chan;
  dma_complete = true;
}

void setup() {
  Serial.begin(115200);
  while (!Serial) {} // Wait for serial connection
  delay(500);

  Serial.println("\n=== DMA to PIO TEST ===");
  Serial.println("Testing DMA transfer to PIO FIFO\n");

  // Setup PIO
  uint offset = pio_add_program(tx_pio, &simple_tx_program);
  tx_sm = pio_claim_unused_sm(tx_pio, true);

  // Slow clock: 1000 Hz
  float clk_div = clock_get_hz(clk_sys) / 1000.0f;
  simple_tx_program_init(tx_pio, tx_sm, offset, TX_DATA_PIN, clk_div);

  Serial.println("PIO initialized");

  // Setup DMA
  dma_chan = dma_claim_unused_channel(true);

  Serial.print("DMA channel: ");
  Serial.println(dma_chan);
  Serial.print("Test buffer address: 0x");
  Serial.println((uint32_t)test_buffer, HEX);
  Serial.print("PIO TX FIFO address: 0x");
  Serial.println((uint32_t)&tx_pio->txf[tx_sm], HEX);

  // Print test buffer contents
  Serial.print("Test buffer contents: ");
  for (int i = 0; i < 8; i++) {
    Serial.print("0x");
    if (test_buffer[i] < 0x10) Serial.print("0");
    Serial.print(test_buffer[i], HEX);
    Serial.print(" ");
  }
  Serial.println("\n");

  // Configure DMA
  dma_channel_config c = dma_channel_get_default_config(dma_chan);
  channel_config_set_transfer_data_size(&c, DMA_SIZE_8);  // 8-bit transfers
  channel_config_set_read_increment(&c, true);             // Increment read address
  channel_config_set_write_increment(&c, false);           // Always write to same FIFO
  channel_config_set_dreq(&c, pio_get_dreq(tx_pio, tx_sm, true)); // Paced by PIO

  dma_channel_configure(
    dma_chan,
    &c,
    &tx_pio->txf[tx_sm],  // Write address: PIO TX FIFO
    test_buffer,          // Read address: our test buffer
    8,                    // Transfer count: 8 bytes
    false                 // Don't start yet
  );

  // Enable interrupt
  dma_channel_set_irq0_enabled(dma_chan, true);
  irq_set_exclusive_handler(DMA_IRQ_0, dma_handler);
  irq_set_enabled(DMA_IRQ_0, true);

  Serial.println("DMA configured, starting transfer in 2 seconds...");
  Serial.println("Watch GPIO 3 for patterns!");
  delay(2000);

  // Start DMA
  Serial.println("DMA STARTED!");
  dma_channel_start(dma_chan);
}

uint32_t last_check = 0;

void loop() {
  // Check DMA status every second
  if (millis() - last_check > 1000) {
    last_check = millis();

    bool busy = dma_channel_is_busy(dma_chan);
    uint32_t transfer_count = dma_channel_hw_addr(dma_chan)->transfer_count;

    Serial.print("DMA Status - Busy: ");
    Serial.print(busy ? "YES" : "NO");
    Serial.print(", Remaining transfers: ");
    Serial.print(transfer_count);
    Serial.print(", Complete flag: ");
    Serial.println(dma_complete ? "YES" : "NO");

    if (dma_complete && !busy) {
      Serial.println("\n=== DMA TRANSFER COMPLETE ===");
      Serial.println("All 8 bytes should have been sent via PIO");
      Serial.println("Check RX output above for pattern sequence");
      while(1); // Stop
    }
  }
}

// Core 1: Monitor RX
void setup1() {
  delay(4000);
  Serial.println("=== CORE 1: RX MONITOR ===\n");

  gpio_init(RX_DATA_PIN);
  gpio_set_dir(RX_DATA_PIN, GPIO_IN);
}

uint8_t last_value = 2;
uint32_t change_count = 0;

void loop1() {
  uint8_t value = gpio_get(RX_DATA_PIN);

  if (value != last_value) {
    Serial.print("RX change #");
    Serial.print(change_count++);
    Serial.print(": GPIO 3 = ");
    Serial.println(value);
    last_value = value;
  }

  delay(10);
}
